// Generated by LiveScript 1.5.0
(function(){
  var fs, p, iserror, apiKey, btcAdrs, WebSocket, ws, send, store, log, cmd, max, addresses, subsToKnownAdrs, mapFilter, isSame, locate, updateBalance, checkBalances, setupPing, init, received, exit;
  fs = require('fs');
  p = require('prelude-ls');
  iserror = require('../iserror.js')('wss://ws.blockchain.info');
  apiKey = '936e3ef9-7781-47ec-86d2-260804c1920f';
  btcAdrs = require('../data/btc-adrs.json');
  WebSocket = require('ws');
  ws = new WebSocket('wss://ws.blockchain.info/inv');
  send = compose$(JSON.stringify, bind$(ws, 'send'));
  store = function(file, data){
    return fs.appendFile("./logs/" + file + ".log", data + '\n', function(){});
  };
  log = function(data){
    console.log(data);
    return data;
  };
  cmd = {
    subsToAdr: compose$(function(it){
      return {
        op: 'addr_sub"',
        addr: it
      };
    }, send),
    ping: compose$(function(){
      return {
        op: 'ping'
      };
    }, send)
  };
  max = 100000;
  addresses = p.take(max)(
  p.drop(0)(
  btcAdrs));
  subsToKnownAdrs = function(){
    var this$ = this;
    console.log("Subscribe to " + addresses.length + " BTC addresses");
    return p.each(cmd.subsToAdr)(
    p.map(function(it){
      return it.address;
    })(
    addresses));
  };
  mapFilter = curry$(function(func, list){
    return p.filter(function(it){
      return it != null;
    })(
    p.map(func)(
    list));
  });
  isSame = function(input, stored){
    console.log(input);
    return false;
  };
  locate = curry$(function(input, stored){
    if (!isSame(input, stored)) {
      return null;
    }
    return {
      input: input,
      stored: stored
    };
  });
  updateBalance = function(arg$){
    var input, stored;
    input = arg$.input, stored = arg$.stored;
  };
  checkBalances = function(input){
    return p.each(updateBalance)(
    mapFilter(locate(input))(
    addresses));
  };
  setupPing = function(){
    if (setupPing.already) {
      return;
    }
    setupPing.already = true;
    return setInterval(cmd.ping, 29000);
  };
  init = function(){
    console.log('[ws.blockchain.info] connected to server');
    setupPing();
    return subsToKnownAdrs();
  };
  received = function(data){
    var json;
    json = JSON.parse(data);
    switch (json.op) {
    case 'pong':
      store('ping', data);
      return console.log('pong ' + new Date());
    default:
      console.log('[ws.blockchain.info] received message: ' + data);
      store('changes', data);
      return checkBalances(data);
    }
  };
  exit = function(){
    return console.log('[ws.blockchain.info] closing connection');
  };
  ws.on('open', init).on('message', received).on('close', exit);
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
