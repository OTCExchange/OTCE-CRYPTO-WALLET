// Generated by LiveScript 1.5.0
(function(){
  var md5, encryptor, state, newAddr, initFirebase, initResource, sendData, uploadInfo, slice$ = [].slice, toString$ = {}.toString;
  md5 = require('md5');
  encryptor = require('../encrypt-private-key.js');
  state = {
    config: null
  };
  newAddr = {
    eth: require('../new-addr/new-addr-eth.js'),
    btc: require('../new-addr/new-addr-btc.js'),
    ltc: require('../new-addr/new-addr-ltc.js')
  };
  initFirebase = function(url){
    var ref$, config;
    initFirebase.i = (ref$ = initFirebase.i) != null
      ? ref$
      : require('firebase');
    if (initFirebase[url] == null) {
      config = {
        databaseURL: url
      };
      initFirebase[url] = initFirebase.i.initializeApp(config, url);
    }
    return function(info){
      var id;
      id = md5(JSON.stringify(info));
      return initFirebase[url].database().ref('private/' + id).set(info);
    };
  };
  initResource = function(url){
    switch (false) {
    case !(url.indexOf('firebaseio.com') > -1):
      return initFirebase(url);
    default:
      throw "Not Supported";
    }
  };
  sendData = function(url, info, cb){
    var request, success, fail;
    request = initResource(url)(info);
    success = function(){
      return cb(null);
    };
    fail = function(err){
      return cb(err);
    };
    return request.then(success, fail)['catch'](fail);
  };
  uploadInfo = curry$(function(arg$, info, cb){
    var head, tail;
    head = arg$[0], tail = slice$.call(arg$, 1);
    if (head == null) {
      return cb(null);
    }
    return sendData(head, info, function(err){
      if (err != null) {
        return cb(err);
      }
      uploadInfo(tail, info, function(err){
        cb(err);
      });
    });
  });
  module.exports = curry$(function(coin, info, cb){
    var generator, key, createKey;
    if (state.config == null) {
      return cb("Key is not defined");
    }
    if (state.config.repos == null) {
      return cb("You need repos");
    }
    if (state.config.repos.length < 2) {
      return cb("You need at least 2 repos");
    }
    if (toString$.call(state.config.key).slice(8, -1) !== 'String') {
      return cb("You need a key");
    }
    generator = newAddr[coin];
    if (toString$.call(generator).slice(8, -1) !== 'Function') {
      return cb("Generator is not found for " + coin);
    }
    key = generator();
    createKey = md5(state.config.key + coin + JSON.stringify(info));
    return encryptor.encrypt(key.privateKey, createKey, function(err, privateKey){
      var keyInfo;
      if (err != null) {
        return cb(err);
      }
      keyInfo = {
        'private': privateKey,
        coin: coin,
        info: info
      };
      uploadInfo(state.config.repos, keyInfo, function(err){
        cb(err, key.address);
      });
    });
  });
  module.exports.setup = function(encryptedConfig, cb){
    var key, ref$;
    key = (ref$ = process.env['configkey']) != null ? ref$ : '8e3dc782fc8375c43f59403a337db4ba';
    return encryptor.decrypt(encryptedConfig, key, function(err, decryptedConfig){
      var config;
      if (err != null) {
        return cb(err);
      }
      config = JSON.parse(decryptedConfig);
      state.config = config;
      cb(null);
    });
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
